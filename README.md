# 设计模式

## 工厂方法模式

- 优点
  - 良好的封装性
  - 工厂方法模式的扩展优秀
  - 屏蔽产品类
  - 解耦
- 使用场景
  - new对象的替代品
  - 产品实现类的不同
- 扩展
  - 简单工厂模式
  - 多个工厂类
  - 单例工厂
  - 延迟初始化

## 抽象工厂模式

- 优点

  - 良好的封装性
  - 产品族内的约束为非公开状态

- 缺点

  - 扩展困难（纵向）

- 使用场景

  - 一个对象族（或一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式

- 最佳实践

  - 涉及到操作系统层面的开发


## 模板方法模式

- 优点
  
  - 封装不变部分，扩展可变部分
  - 提取公共部分代码，便于维护
  - 行为由父类控制，子类实现
  
- 缺点

  - 子类影响父类，阅读难度提高

- 使用场景

  - 多个子类有公有的方法，并且逻辑基本相同
  - 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现
  - 项目重构时，相同代码抽到父类通过钩子函数（Hook Method）约束行为

- 扩展

  - Hook Method 钩子方法

## 建造者模式（生成器模式）

- 优点
  - 封装性
  - 易扩展
  - 便于控制细节风险
- 使用场景
  - 相同的方法，不同的执行顺序，产生不同的事件结果时
  - 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时
  - 产品类复杂，或产品类中的调用顺序不同产生了不同的效能
  - 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时
- 注意事项
  - 关注的是零件的类型和装配工艺（顺序），这是它与工厂方法模式最大的不同
- 最佳实践
  - 考虑模板方法模式



## 代理模式